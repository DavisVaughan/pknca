---
title: "PKNCA Training Session 1 of 2"
author: "William Denney"
date: "5 November 2021"
output:
  ioslides_presentation:
    widescreen: true
vignette: >
  %\VignetteIndexEntry{PKNCA Training Session 1 of 2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
requireNamespace("pmxTools")
library(PKNCA)
library(tidyverse)
breaks_hours <- function(n=5, Q=c(1, 6, 4, 12, 2, 24, 168), ...) {
  n_default <- n
  Q_default <- Q
  function(x, n = n_default, Q=Q_default) {
    x <- x[is.finite(x)]
    if (length(x) == 0) {
      return(numeric())
    }
    rng <- range(x)
    labeling::extended(rng[1], rng[2], m=n, Q=Q, ...)
  }
}

scale_x_hours <- function(..., breaks=breaks_hours()) {
  ggplot2::scale_x_continuous(..., breaks=breaks)
}
```

<style>
.forceBreak { -webkit-column-break-after: always; break-after: column; }

<!-- from https://stackoverflow.com/questions/1909648/stacking-divs-on-top-of-each-other -->
.container {
  width: 300px;
  height: 300px;
  margin: 0 auto;
  background-color: yellow;
  /* important part */
  display: grid;
  place-items: center;
  grid-template-areas: "inner-div";
}

.inner {
  /* important part */
  grid-area: inner-div;
}

.bigStrikethroughOuter {
  <!-- text-decoration: line-through; -->
  font-size: 8em;
  text-align: center;
  color: red;
  background: 
  linear-gradient(to top left,
    transparent 0%,
    transparent calc(50% - 0.05em),
    red calc(50% - 0.05em),
    red 50%,
    red calc(50% + 0.05em),
    transparent calc(50% + 0.05em),
    transparent 100%),
  linear-gradient(to top right,
    transparent 0%,
    transparent calc(50% - 0.05em),
    red calc(50% - 0.05em),
    red 50%,
    red calc(50% + 0.05em),
    transparent calc(50% + 0.05em),
    transparent 100%);
}

.bigStrikethroughInner {
  color: blue;
  font-size: 8em;
}

.autoImageWidth {
  width: auto !important; /*override the width below*/
  max-width: 100%;
  float: left;
  clear: both;
  text-align: center;
}

</style>

# Introduction to PKNCA and Basics of Its Use

## Introduction to PKNCA {.build .smaller}

PKNCA is a tool for calculating noncompartmental analysis (NCA) results for pharmacokinetic (PK) data.

... but, you already knew that or you wouldn't be here.

PKNCA has several foci:

* be regulatory-ready
    * it has approximately 100% test coverage.
* be reproducible
    * it has a focus on being scriptable.
* get the right answer or none at all
    * it will try to know what you want,
    * but all decisions can be overridden, and
    * if there is a question that may cause an error or an unanticipated result, either no result will output or an error will be raised.

## Enjoy! {.build}

I hope that you have a whale of a good time during this training.

![](https://apps-afsc.fisheries.noaa.gov/Quarterly/amj2005/images/killerwhales.jpg)

(Foreshadowing...)

## Some NCA Definitions

* **C~max~**: The maximum observed concentration
* **T~max~**: The time of the maximum observed concentration
* **t~last~**: The time of the last concentration above the limit of quantification
* **AUC**: Area under the concentration-time curve.  Some important AUC variants are:
    * **AUC~last~**: AUC from time zero to t~last~
    * **AUC~int~**: AUC from time zero to the end of an interval of time, often extrapolated or interpolated (e.g. AUC~0-24hr~)
    * **AUC~&infin;~**: AUC from time zero to t~last~ then extrapolated from t~last~ to time infinity using the half life

# Dataset Basics

## NCA Data are Not Tidy ***as a Single Dataset***

"Tidy datasets... have a specific structure: each variable is a column, each observation is a row, and each type of observational unit is a table." - Hadley Wickham (https://doi.org/10.18637/jss.v059.i10)

CDISC has NCA tidied, and PKNCA follows that model:

* concentration-time is a dataset (PC domain; `PKNCAconc()` object)
* dose-time is a dataset (EX/EC domains; `PKNCAdose()` object)
* NCA results are a dataset (PP domain; `pk.nca()` output)

## Dataset Basics: Minimum data

PKNCA requires at minimum concentration, time, and what you want to calculate.

```{r fig.width=6, fig.height=4}
conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
ggplot(conc, aes(x=Time, y=conc)) +
  geom_line() +
  scale_x_hours()
```

## Dataset Basics: What columns are needed?

Column names are provided by the input to `PKNCAconc()` and `PKNCAdose()`; they are not hard-coded.

Columns that can be used include:

* `PKNCAconc()`: concentration, time, groups; data exclusions; half-life inclusion and exclusion
* `PKNCAdose()`: dose, time, groups; route, rate/duration of infusion; data exclusions
* intervals given to `PKNCAdata()`: groups, start, end, and any NCA parameters to calculate

## Dataset Basics:  Example data

In the following slides, abbreviated data from an example study where two treatments ("A" and "B") are administered to two subjects (1 and 2).

* For PKNCA, the groups will be **Treatment** and **Subject**.
    * PKNCA considers groups in order with the subject identifier as the last group (or the last group before a forward slash, `/`, if `/` is present).
    * When indicated in order (`...|Treatment+Subject`), PKNCA automatically knows to keep **Treatment** and drop **Subject** for summaries (more on that later).

## Dataset Basics:  Example concentration data {.columns-2}

```{r}
conc_data <-
  withr::with_seed(5, {
    data.frame(
      Subject=rep(1:2, each=6),
      Treatment=rep(c("A", "B", "A", "B"), each=3),
      Time=rep(c(0, 2, 8), 4),
      Conc=rep(c(0, 2, 0.5), 4)*exp(rnorm(n=12, sd=0.05))
    )
  })
```

```{r}
pander::pander(conc_data %>% filter(Subject == 1))
```

<p class="forceBreak"></p>

```{r}
pander::pander(conc_data %>% filter(Subject == 2))
```

## Dataset Basics:  Example dosing data

```{r}
dose_data <-
  data.frame(
    Subject=rep(1:2, each=2),
    Treatment=c("A", "B", "A", "B"),
    Time=0,
    Dose=10
  )
```

```{r}
pander::pander(dose_data %>% filter(Subject == 1))
```

<p class="forceBreak"></p>

```{r}
pander::pander(dose_data %>% filter(Subject == 2))
```

## Dataset Basics:  Example interval data

```{r, echo=TRUE}
d_interval_1 <-
  data.frame(
    start=0, end=8,
    cmax=TRUE, tmax=TRUE, auclast=TRUE
  )
```

```{r}
pander::pander(d_interval_1)
```

Groups are not required, if you want the same intervals calculated for each group.

## Hands-on: First NCA calculation with PKNCA

```{r echo=TRUE}
library(tidyverse)
library(PKNCA)
# Concentration data setup
d_conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
o_conc <- PKNCAconc(conc~Time, data=d_conc)
# Setup intervals for calculation
d_intervals <- data.frame(start=0, end=24, cmax=TRUE, tmax=TRUE, auclast=TRUE, aucint.inf.obs=TRUE)
# Combine concentration and dose
o_data <- PKNCAdata(o_conc, intervals=d_intervals)
# Calculate the results (suppressMessages() hides a message that isn't needed now)
o_result <- suppressMessages(pk.nca(o_data))
# summary(o_result)
```

# PKNCA Functions

## What functions are the most used?

* `PKNCAconc()`: define a concentration-time `PKNCAconc` object
    * All information about concentration data are given:  concentration, time
    * Optional information includes: grouping information (usually given), data to exclude, half-life inclusion and exclusion columns
* `PKNCAdose()`: define a dose-time `PKNCAdose` object (optional)
    * dose amount and time are both optional
    * Optional information includes: rate or duration of infusion, data to exclude
* `PKNCAdata()`: combine `PKNCAconc`, optionally `PKNCAdose`, and optionally `intervals` into a `PKNCAdata` object
    * the `PKNCAconc` object must be given; the `PKNCAdose` object is optional; interval definitions are usually given; calculation options may be given
* `pk.nca()`: calculate the NCA parameters from a data object into a `PKNCAresult` object

## How do I do a simple calculation? all steps

We will break this down in subsequent slides.

```{r echo=TRUE}
# Concentration data setup
d_conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
o_conc <- PKNCAconc(conc~Time, data=d_conc)
# Dose data setup
d_dose <-
  datasets::Theoph %>%
  filter(Subject %in% 1) %>%
  filter(Time == 0)
o_dose <- PKNCAdose(Dose~Time, data=d_dose)
# Combine concentration and dose
o_data <- PKNCAdata(o_conc, o_dose)
# Calculate the results
o_result <- pk.nca(o_data)
```

## How do I do a simple calculation? Concentration data {.smaller}

```{r echo=TRUE}
# Load your dataset as a data.frame
d_conc <-
  datasets::Theoph %>%
  filter(Subject %in% 1)
# Take a look at the data
pander::pander(head(d_conc, 2))
# Define the PKNCAconc object indicating the concentration and time columns, the
# dataset, and any other options.
o_conc <- PKNCAconc(conc~Time, data=d_conc)
```

## How do I do a simple calculation? Dose data {.smaller}

```{r echo=TRUE}
# Load your dataset as a data.frame
d_dose <-
  datasets::Theoph %>%
  filter(Subject %in% 1) %>%
  filter(Time == 0)
# Take a look at the data
pander::pander(d_dose)
# Define the PKNCAdose object indicating the dose amount and time columns, the
# dataset, and any other options.
o_dose <- PKNCAdose(Dose~Time, data=d_dose)
```

## How do I do a simple calculation? Calculate results {.smaller}

```{r echo=TRUE}
# Combine the PKNCAconc and PKNCAdose objects.  You can add interval
# specifications and calculation options here.
o_data <- PKNCAdata(o_conc, o_dose)
# Calculate the results
o_result <- pk.nca(o_data)
```

## How do I do a simple calculation?  Get results

To calculate summary statistics, use `summary()`; to extract all individual-level results, use `as.data.frame()`.

The `"caption"` attribute of the summary describes how the summary statistics were calculated for each parameter.  (Hint: `pander::pander()` knows how to use that to put the caption on a table in a report.)

The individual results contain the columns for start time, end time, grouping variables (none in this example), parameter names, values, and if the value should be excluded.

## How do I do a simple calculation?  Get summary results {.smaller}

```{r echo=TRUE}
# Look at summarized results
pander::pander(summary(o_result))
```

## How do I do a simple calculation?  Get individual results {.smaller}

```{r}
# Look at individual results
pander::pander(head(
  as.data.frame(o_result),
  n=3
))
```

# PKNCA datasets

## How does PKNCA think about data?

Three types of data are inputs for calculation in PKNCA:

* concentration-time (`PKNCAconc`),
* dose-time (`PKNCAdose`), and
* intervals.

`PKNCAconc` and `PKNCAdose` objects can optionally have groups.  The groups in a `PKNCAdose` object must be the same or fewer than the groups in `PKNCAconc` object (for example, all subjects in a treatment arm may receive the same dose).

## What is an "interval" and how is it different than a "group"? {.columns-2 .smaller}

```{r interval-vs-groups-setup, echo=FALSE}
last_dose_time <- 24
dose_interval <- 8
dose_times <- seq(0, last_dose_time-dose_interval, by=dose_interval)
d_conc_superposition <-
  superposition(
    o_conc,
    dose.times=dose_times,
    tau=last_dose_time,
    check.blq=FALSE,
    n.tau=1
  )
```

A **group** separates one full concentration-time profile for a subject that you may ever want to consider at the same time.  Usually, it groups by study, treatment, analyte, and subject (other groups can be useful depending on the study design).

An **interval** selects a time range within a **group**.

One time can be in zero or more intervals, but only zero or one group.  Intervals can be adjacent (0-12 and 12-24) or overlap (0-12 and 0-24).  In other words, one sample may be used in more than one interval, but one sample will never be used in more than one group.

**Legend:**  The group contains all points on the figure.  Shaded regions indicate intervals.  Arrows indicate points shared between intervals within the group.

<p class="forceBreak"></p>

```{r fig.width=4, fig.height=4}
d_intervals <-
  tibble(
    start=dose_times,
    end=dose_times + dose_interval
  ) %>%
  mutate(
    name=sprintf("Interval %g", row_number()),
    height=max(d_conc_superposition$conc)*1.03,
    width=dose_interval,
    x=(start+end)/2,
    y=height/2
  )
d_interval_arrows <-
  d_conc_superposition %>%
  filter(time != 0 & time %in% dose_times) %>%
  mutate(
    name1=sprintf("Interval %g", row_number()),
    name2=sprintf("Interval %g", row_number() + 1),
  )
ggplot(d_conc_superposition, aes(x=time, y=conc)) +
  geom_tile(
    data=d_intervals,
    aes(x=x, y=y, width=width, height=height, colour=name, fill=name),
    alpha=0.2,
    inherit.aes=FALSE,
    show.legend=FALSE
  ) +
  geom_segment(
    data=d_interval_arrows,
    aes(x=time - 0.8, xend=time - 0.1, y=conc-2.1, yend=conc - 0.1, colour=name2),
    arrow=arrow(length=unit(0.1, "inches")),
    inherit.aes=FALSE,
    show.legend=FALSE
  ) +
  geom_segment(
    data=d_interval_arrows,
    aes(x=time + 0.8, xend=time + 0.1, y=conc-2.1, yend=conc - 0.1, colour=name1),
    arrow=arrow(length=unit(0.1, "inches")),
    inherit.aes=FALSE,
    show.legend=FALSE
  ) +
  geom_line() +
  geom_point() +
  scale_x_hours() +
  labs(
    title=sprintf("Dosing Q%gH", dose_interval)
  )
```

## Common data management requirements before sending data to PKNCA {.smaller}

1. Time must not be missing for `PKNCAconc` (if given to `PKNCAdose`, it must not be missing).
2. Below the limit of quantification (BLQ) concentrations must be set to zero (not `NA`).
3. Imputation of time zero is required for AUC calculation.
4. Especially for actual-time calculations, imputation of the beginning of the interval is usually needed.

Columns must be created for:

* Concentration or dose,
* Time
* Groups
    * usually columns for study, treatment arm, subject;
    * sometimes analyte, formulation, period (needed in case the same subject receives the same treatment arm multiple times)

## Setup your concentration data {.columns-2}

* Concentration data must be numeric

<p class="forceBreak"></p>

<div class="bigStrikethroughOuter">
<div class="bigStrikethroughInner">A</div>
</div>

## Setup your concentration data {.columns-2}

* Concentration data must be numeric
* Time must be numeric and not be missing

<p class="forceBreak"></p>

<div class="bigStrikethroughOuter">
<div class="bigStrikethroughInner">NA</div>
</div>

## Setup your concentration data {.columns-2}

* Concentration data must be numeric
* Time must be numeric and not be missing
* Groups can be anything, setup at the level of the individual

<p class="forceBreak"></p>

<div class="autoImageWidth">
![](https://apps-afsc.fisheries.noaa.gov/Quarterly/amj2005/images/killerwhales.jpg)<br />
Group: <span style="color: green;">&#128504;</span> a pod of killer whales
</div>

## Setup your dosing data (if you have it and even if you don't) {.smaller}

Normal dosing data setup: `PKNCAdose(dose~time|actarm+usubjid, data=d_dose)`

* Dose amount must be numeric &mdash; or it can be omitted
    * `PKNCAdose(~time|actarm+usubjid, data=d_dose)`
* Time must be numeric and not be missing &mdash; or it can be omitted
    * `PKNCAdose(dose~.|actarm+usubjid, data=d_dose)`
* Groups can be anything &mdash; may be grouped at a higher level than the individual
    * Useful when all dose amounts and times are the same within an arm: `PKNCAdose(dose~time|actarm, data=d_dose)`
    * Useful dose amount is the same at all times within an arm: `PKNCAdose(dose~.|actarm, data=d_dose)`
    * Useful when times are all the same within an arm but dose may differ: `PKNCAdose(~time|actarm, data=d_dose)`

## Define your intervals

Intervals have columns for:

* `start` and `end` times for the interval,
* groups matching any level of grouping; intervals apply by a merge/join with the groups
* parameters to calculate (`TRUE` means to calculate it; `FALSE` means don't).  The full list of available parameters is in the [selection of calculation intervals vignette](http://billdenney.github.io/pknca/articles/Selection-of-Calculation-Intervals.html#parameters-available-for-calculation-in-an-interval-1).
    * You only have to specify the parameter you want, not all parameters.

## Define your intervals: example

* For time 0 to 24, calculate AUClast
* For time 0 to infinity, calculate cmax, tmax, half.life, and aucinf.obs

```{r}
PKNCA.options("single.dose.aucs") %>%
  select(c(all_of(c("start", "end")), where(~is.logical(.x) && any(.x)))) %>%
  pander::pander()
```

# Calculations above the hood

## Prepare your data for calculation

```{r echo=TRUE}
d_conc <-
  datasets::Theoph %>%
  mutate(
    Treatment=
      case_when(
        Dose <= median(Dose)~"Low dose",
        TRUE~"High dose"
      )
  )
# The study was single-dose
d_dose <-
  d_conc %>%
  select(Treatment, Subject, Dose) %>%
  unique() %>%
  mutate(dose_time=0)
```

## Calculate without dosing data {.build}

```{r echo=TRUE}
o_conc <- PKNCAconc(conc~Time|Treatment+Subject, data=d_conc)
try({
  o_data <- PKNCAdata(o_conc)
  summary(pk.nca(o_data))
})
```

Whoops!  Without dosing, we need intervals.

## Calculate without dosing data, try 2

```{r echo=TRUE}
o_conc <- PKNCAconc(conc~Time|Treatment+Subject, data=d_conc)
d_intervals <- data.frame(start=0, end=Inf, cmax=TRUE, tmax=TRUE, half.life=TRUE, aucinf.obs=TRUE)
o_data_manual_intervals <- PKNCAdata(o_conc, intervals=d_intervals)
summary(pk.nca(o_data_manual_intervals))
```

## Dosing data helps with interval setup

```{r echo=TRUE}
o_conc <- PKNCAconc(conc~Time|Treatment+Subject, data=d_conc)
o_dose <- PKNCAdose(Dose~dose_time|Treatment+Subject, data=d_dose)
o_data_auto_intervals <- PKNCAdata(o_conc, o_dose)
o_data_auto_intervals$intervals$aucint.inf.obs <- TRUE
summary(pk.nca(o_data_auto_intervals))
```

## AUC considerations with PKNCA (1/3) {.columns-2}

```{r auc-considerations-setup, warning=FALSE}
d_conc <-
  datasets::Theoph %>%
  filter(Subject == 1)
o_conc <- PKNCAconc(conc~Time, data=d_conc)
d_interval_int <- data.frame(start=0, end=Inf, half.life=TRUE)
o_data_int <- PKNCAdata(o_conc, intervals=d_interval_int)
o_nca_int <- suppressMessages(pk.nca(o_data_int))
lambda_z_int <-
  o_nca_int %>%
  as.data.frame() %>%
  filter(PPTESTCD %in% "lambda.z") %>%
  "[["("PPORRES")

d_interval_inf <- data.frame(start=0, end=24, half.life=TRUE)
o_data_inf <- PKNCAdata(o_conc, intervals=d_interval_inf)
o_nca_inf <- suppressMessages(pk.nca(o_data_inf))
lambda_z_inf <-
  o_nca_inf %>%
  as.data.frame() %>%
  filter(PPTESTCD %in% "lambda.z") %>%
  "[["("PPORRES")

tlast <- 
  o_nca_inf %>%
  as.data.frame() %>%
  filter(PPTESTCD %in% "tlast") %>%
  "[["("PPORRES")

d_auc_calcs <-
  d_conc %>%
  bind_rows(
    tibble(Time=seq(12, 60))
  ) %>%
  mutate(
    conc_all_int=
      interp.extrap.conc(
        conc=conc[!is.na(conc)],
        time=Time[!is.na(conc)],
        time.out=Time,
        lambda.z=lambda_z_int
      ),
    conc_all_inf=
      interp.extrap.conc(
        conc=conc[!is.na(conc) & Time <= 24],
        time=Time[!is.na(conc) & Time <= 24],
        time.out=Time,
        lambda.z=lambda_z_inf
      ),
    conc_last=
      case_when(
        Time <= 24~conc,
        TRUE~NA_real_
      ),
    conc_int=
      case_when(
        Time <= 24 & Time >= tlast~conc_all_int,
        TRUE~NA_real_
      ),
    conc_inf=
      case_when(
        Time >= tlast~conc_all_inf,
        TRUE~NA_real_
      )
  ) %>%
  arrange(Time)
auc_figure_time_max <- 36
p_auc_calcs <-
  ggplot(d_auc_calcs, aes(x=Time, y=conc)) +
  # AUCinf (with a work-around for https://github.com/tidyverse/ggplot2/issues/4661)
  geom_area(
    data=d_auc_calcs %>% filter(Time <= auc_figure_time_max),
    aes(y=conc_inf, colour="AUCinf", fill="AUCinf"),
    alpha=0.2,
    na.rm=TRUE
  ) +
  geom_line(
    data=d_auc_calcs,
    aes(y=conc_inf, colour="AUCinf"),
    na.rm=TRUE
  ) +
  # AUCint
  geom_area(
    aes(y=conc_int, colour="AUCint", fill="AUCint"),
    alpha=0.2,
    na.rm=TRUE
  ) +
  # AUClast
  geom_area(
    aes(y=conc_last, colour="AUClast", fill="AUClast"),
    na.rm=TRUE
  ) +
  geom_point(show.legend=FALSE,
    na.rm=TRUE) +
  geom_line(show.legend=FALSE,
    na.rm=TRUE) +
  geom_vline(xintercept=24, linetype="63") +
  scale_x_continuous(breaks=seq(0, auc_figure_time_max, by=6)) +
  coord_cartesian(xlim=c(0, auc_figure_time_max)) +
  labs(
    colour="AUC type",
    fill="AUC type"
  )
```

```{r warning=FALSE, out.width="100%"}
p_auc_calcs
```

<p class="forceBreak"></p>

The considerations below mainly apply to actual-time data; nominal-time data usually have measurements at the start and end time for the interval.

With an interval start and end of 0 and 24 (and the last measurement time just after 24 hours):

* **AUC~last~** is calculated only based on points within the interval (the AUClast color in the figure)

## AUC considerations with PKNCA (2/3) {.columns-2}

```{r warning=FALSE, out.width="100%"}
p_auc_calcs
```

<p class="forceBreak"></p>

The considerations below mainly apply to actual-time data; nominal-time data usually have measurements at the start and end time for the interval.

With an interval start and end of 0 and 24 (and the last measurement time just after 24 hours):

* **AUC~int~** looks at the points in the interval, and if there is no measurement at the interval end time, interpolates or extrapolates to the interval end time (the AUClast and AUCint color in the figure)

## AUC considerations with PKNCA (2/3) {.columns-2}

```{r warning=FALSE, out.width="100%"}
p_auc_calcs
```

<p class="forceBreak"></p>

The considerations below mainly apply to actual-time data; nominal-time data usually have measurements at the start and end time for the interval.

With an interval start and end of 0 and 24 (and the last measurement time just after 24 hours):

* **AUC~&infin;~** is calculated based on AUC~last~, t~last~, and the half-life from t~last~, only using data within the interval-- no data after the end of the interval.
* Ensure that the interval used for calculating AUC~&infin;~ includes all the points desired (usually, `end=Inf`).

# Hands-on workshop

## Steady-state intramuscular administration

The data for the exercise are from a PK study of amikacin in a killer whale and a beluga whale.  (DOI: 10.1638/03-078)

![](https://apps-afsc.fisheries.noaa.gov/Quarterly/amj2005/images/killerwhales.jpg)

(Callback...)

## Steady-state intramuscular administration

```{r eval=FALSE, echo=TRUE}
library(PKNCA)

d_conc <- read.csv("c:/tmp/whale_conc.csv")
d_dose <- read.csv("c:/tmp/whale_dose.csv")
head(d_conc)
head(d_dose)

o_conc <- PKNCAconc(concentration~time|Animal, data=d_conc)
o_dose <- PKNCAdose(dose~time|Animal, data=d_dose)
o_data <- PKNCAdata(o_conc, o_dose)
o_data$intervals
o_nca <- pk.nca(o_data)
summary(o_nca)
summary(o_nca, drop.group=c())
as.data.frame(o_nca)
```
